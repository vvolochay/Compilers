# Что должно быть установлено в системе #

* qemu
* cabal

# Установка эмулятора #

В папке `vm` лежит файл `download.sh`, который скачает всё необходимое
для запуска виртуальной машины (всё взято отсюда:
https://people.debian.org/~aurel32/qemu/armel/).

Затем, `run.sh` запустит виртуальную машину (несколько минут). После
запуска, можно будет заходить на неё по ssh на 2222 порту. Пароли:
user/user, root/root.

На виртуальной машине выполнить:

``````
~# apt-get update && apt-get install -y gcc strace
``````

Убедиться, что `as` и `ld` установились.

# Установка компилятора #

``````
cabal install 
``````

После этого должен появиться файл `~/.cabal/bin/fcc`. Это компилятор,
который принимает на вход программу, и выводит на стандартный вывод
ассемблер для ARM. Процесс компиляции и запуска:

`````
local $ fcc < examples/cat.fc > cat.S
local $ scp -P 2222 cat.S user@localhost:~
user@debian-armel $ as cat.S -o cat.o
user@debian-armel $ ld cat.o -o cat
user@debian-armel $ echo hello | ./cat
hello
`````

# Как запустить что-то, отличное от `cat` #

В остальных примерах не используется ввод-вывод, а для этого результат
возвращается из функции main как код возврата. Наглядно за этим можно,
например, наблюдать, запуская программу через strace и смотря на
аргумент, с которым вызван системный вызов `exit`

# Оптимизации #

Реализовано два вида оптимизаций:

* Удаление ненужного кода
Начинаем с точки входа, смотрим, какие функции и глобальные
переменные достижимы, остальные удаляем
* Пытаемся посчитать значения подвыражений
  * Выделяем <<хорошие>> функции и пытаемся вычислять их во время компиляции
  * Хорошие --- те, которые не используют <<неправильных>>
  <<библиотечных>> вызовов, массивов (TBD) и глобальных переменных
  * Удаляем недостижимый код и упраздняем очевидные `if`-ы и `while`-ы
  * Вычислятор -решает проблему останова- делает 10000 итераций и
  успокаивается, если вычислить не удалось

Примеры хорошо оптимизируемых программ: `examples/fact.fc`,
`examples/sum.fc`

